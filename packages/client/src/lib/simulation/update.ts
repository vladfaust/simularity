import { d } from "@/lib/drizzle";
import { ref, shallowRef, type Ref, type ShallowRef } from "vue";
import type { StateCommand, StateDto } from "./state";

export class UpdateVariant {
  readonly directorUpdate: ShallowRef<
    | Pick<
        typeof d.directorUpdates.$inferSelect,
        "id" | "code" | "preference" | "createdAt"
      >
    | null
    | undefined
  >;

  readonly state: ShallowRef<StateDto | undefined>;
  readonly ttsPath: Ref<string | null | undefined>;

  constructor(
    /**
     * The writer update for this variant.
     */
    readonly writerUpdate: Pick<
      typeof d.writerUpdates.$inferSelect,
      | "id"
      | "llmCompletionId"
      | "nextUpdateId"
      | "checkpointId"
      | "didConsolidate"
      | "characterId"
      | "simulationDayClock"
      | "text"
      | "createdByPlayer"
      | "episodeId"
      | "episodeChunkIndex"
      | "preference"
      | "createdAt"
    > & {
      /**
       * LLM completion for this writer update.
       * Null means there is no completion for this variant (generated by user).
       * Undefined means completion state is unknown.
       */
      completion?: Pick<
        typeof d.llmCompletions.$inferSelect,
        "inputLength" | "outputLength"
      > | null;
    },

    /**
     * The director update, if any.
     * Null means there is no director update for this variant.
     * Undefined means the director update is unknown.
     */
    directorUpdate?: Pick<
      typeof d.directorUpdates.$inferSelect,
      "id" | "code" | "preference" | "createdAt"
    > | null,

    /**
     * The state of the simulation at the time of the update, if known.
     */
    state?: StateDto | undefined,

    /**
     * TTS file path.
     * Null means there is no TTS for this variant.
     * Undefined means TTS state is unknown.
     */
    ttsPath?: string | null | undefined,
  ) {
    this.directorUpdate = shallowRef(directorUpdate);
    this.state = shallowRef(state);
    this.ttsPath = ref(ttsPath);
  }

  get completionLength(): number | undefined {
    const completion = this.writerUpdate.completion;
    if (!completion) return undefined;

    if (completion.inputLength === null || completion.outputLength === null) {
      return undefined;
    }

    return completion.inputLength + completion.outputLength;
  }

  get consolidated() {
    return this.writerUpdate.didConsolidate;
  }
}

export class Update {
  readonly variants: ShallowRef<UpdateVariant[]>;
  readonly chosenVariantIndex = ref(0);

  readonly inProgressVariant = ref<
    | {
        writerUpdate: {
          characterId?: string | null;
          clockString?: string;
          text: string;
        };
        directorUpdate?: StateCommand[];
      }
    | undefined
  >();

  constructor(
    readonly parentId: number | null | undefined,
    variants: UpdateVariant[] = [],
    chosenVariantIndex = 0,
  ) {
    this.variants = shallowRef(variants);
    this.chosenVariantIndex.value = chosenVariantIndex;
  }

  get completionLength(): number | undefined {
    const chosenVariant = this.chosenVariant;
    if (!chosenVariant) return undefined;

    return chosenVariant.completionLength;
  }

  get chosenVariant() {
    return this.variants.value.at(this.chosenVariantIndex.value);
  }

  /**
   * Ensure that the chosen variant is defined.
   * @throws {Error} If the chosen variant is undefined.
   */
  get ensureChosenVariant() {
    const chosenVariant = this.chosenVariant;
    if (!chosenVariant) throw new Error("Chosen variant undefined");
    return chosenVariant;
  }

  /**
   * Set the chosen variant to the last one.
   * @throws {Error} If there are no variants.
   */
  setChosenVariantToLast() {
    if (this.variants.value.length === 0) throw new Error("No variants");
    this.chosenVariantIndex.value = this.variants.value.length - 1;
  }
}
