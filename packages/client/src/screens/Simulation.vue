<script setup lang="ts">
import { type Raw, computed, markRaw, onMounted, onUnmounted, ref } from "vue";
import { type Scenario } from "@/lib/types";
import { DefaultScene } from "../lib/simulation/phaser/defaultScene";
import DeveloperConsole from "./Simulation/DeveloperConsole.vue";
import { Deferred, clone, assert, assertFn, unreachable } from "@/lib/utils";
import {
  buildStaticPrompt,
  buildDynamicPrompt,
  writerResponsePrefix,
  USER_PREFIX,
  AI_PREFIX,
  writerGrammar,
} from "@/lib/ai/writer";
import { Game } from "../lib/simulation/phaser/game";
import { d, sqlite, parseSelectResult } from "@/lib/drizzle";
import { and, asc, eq, inArray, isNull, sql } from "drizzle-orm";
import { Stage, type StageCall, type StageState } from "@/lib/simulation/stage";
import GptStatus from "./Simulation/GptStatus.vue";
import {
  FastForwardIcon,
  Loader2Icon,
  MenuIcon,
  ScrollTextIcon,
  SendHorizontalIcon,
  ShapesIcon,
  SkipForwardIcon,
  XIcon,
} from "lucide-vue-next";
import { SQLiteSyncDialect } from "drizzle-orm/sqlite-core";
import { writerUpdatesTableName } from "@/lib/drizzle/schema/writerUpdates";
import { TransitionRoot } from "@headlessui/vue";
import { appLocalDataDir, join } from "@tauri-apps/api/path";
import {
  BaseDirectory,
  createDir,
  exists,
  writeBinaryFile,
} from "@tauri-apps/api/fs";
import prettyBytes from "pretty-bytes";
import { Gpt, type InferenceOptions } from "@/lib/ai";
import SandboxConsole from "./Simulation/SandboxConsole.vue";
import { stageCallsToLua, comparesDeltas } from "@/lib/simulation/stage";
import { useInfiniteScroll, useScroll } from "@vueuse/core";
import AssistantUpdateVue from "./Simulation/AssistantUpdate.vue";
import UserUpdateVue from "./Simulation/UserUpdate.vue";
import EpisodeUpdateVue from "./Simulation/EpisodeUpdate.vue";
import {
  AssistantUpdate,
  UserUpdate,
  EpisodeUpdate,
  type Update,
} from "@/lib/simulation/updates";
import Menu from "./Simulation/Menu.vue";
import router, { routeLocation } from "@/lib/router";
import * as settings from "@/settings";

const { simulationId } = defineProps<{ simulationId: string }>();

let gameInstance: Game;
let stage: Stage;
let scene: DefaultScene;

let scenario = ref<Scenario | undefined>();
const assetBaseUrl = ref<URL | undefined>();

/**
 * The runtime simulation state object.
 */
const state = ref<{
  currentEpisode: (Scenario["episodes"][0] & { nextChunkIndex: number }) | null;
}>({ currentEpisode: null });

/**
 * Previous meaningful stage state.
 */
const previousStageState = ref<StageState | undefined | null>();

/**
 * Simulation updates, ordered from the newest to the oldest.
 */
const updates = ref<Raw<Update>[]>([]);

/**
 * The latest (i.e. the first) update, if any.
 */
const latestUpdate = computed(() => updates.value.at(0));

const busy = ref(false);

const writer = ref<Gpt | undefined>();
const deferredWriter = new Deferred<Gpt>();

/** The committed writer prompt, always trimmed. */
const committedWriterPrompt = ref("");

const uncommittedPlayerInput = ref("");
const uncommittedAssistantText = ref("");

/** The uncommitted writer prompt, always trimmed. */
const uncommittedWriterPrompt = computed(() => {
  let value = "";

  if (uncommittedPlayerInput.value)
    value += USER_PREFIX + uncommittedPlayerInput.value + "\n";
  if (uncommittedAssistantText.value)
    value += AI_PREFIX + uncommittedAssistantText.value + "\n";

  return value;
});
const uncommittedWriterKvCacheKey = ref<string | undefined>();

const _canvasFade = ref(true);

const consoleModal = ref(false);
// FIXME: Proper episode display.
const currentEpisodeConsoleObject = computed(() =>
  state.value.currentEpisode
    ? {
        id: state.value.currentEpisode.id,
        chunks: {
          current: state.value.currentEpisode.nextChunkIndex - 1,
          total: state.value.currentEpisode.chunks.length,
        },
      }
    : null,
);

const showSandboxConsole = ref(false);
const showMenu = ref(false);

const playerInput = ref("");
const userInputEnabled = computed(
  () => !busy.value && !state.value.currentEpisode,
);

const updatesScrollOffsetY = ref(0);
const updatesRef = ref<HTMLElement | null>(null);
useInfiniteScroll(updatesRef, () => {}, {
  direction: "top",
});
useScroll(updatesRef, {
  onScroll(e) {
    updatesScrollOffsetY.value = (e.target as HTMLDivElement).scrollTop;
  },
});

const modelSettings = ref<InferenceOptions>({
  temp: 1.15,
  minP: 0.1,
  mirostat: {
    tau: 5,
    eta: 0.1,
  },
});

function consoleEventListener(event: KeyboardEvent) {
  // Detect tilda key press on different keyboard layouts.
  // FIXME: Enable [, disable when input fields is focused.
  if (["~", "ยง", "`", ">"].includes(event.key)) {
    consoleModal.value = !consoleModal.value;
    event.preventDefault();
  }
}

/**
 * Prerequisites: can only be called when the latest update
 * is assistant-created, and there is no inference in-progress.
 *
 * 1. Commit the changes generated by latest inference.
 * If not committed, pending changes will be discarded
 * upon the next inference /decoding.
 *
 * 2. If the stage state delta is different from the director update,
 * save the new director update to database.
 *
 * 3. Save the stage state to be able to reset it later.
 */
async function commitUncommitted() {
  const promises = [];

  if (uncommittedWriterKvCacheKey.value) {
    promises.push(
      deferredWriter.promise.then((writer) =>
        writer.commit().then((tokens) => {
          console.debug("Committed to writer", tokens);
          committedWriterPrompt.value += "\n" + uncommittedWriterPrompt.value;
          uncommittedPlayerInput.value = "";
          uncommittedAssistantText.value = "";
          uncommittedWriterKvCacheKey.value = undefined;
        }),
      ),
    );
  }

  // Check if the actual stage delta differs from the latest director update.
  // If so, save the actual delta as a new director update.
  if (latestUpdate.value instanceof AssistantUpdate) {
    const update = latestUpdate.value as AssistantUpdate;

    const actualDelta = stage.delta(previousStageState.value);
    console.debug("Actual delta", actualDelta);

    console.debug(
      "Latest director update delta",
      update.chosenVariant.directorUpdate?.code,
    );

    const deltasEqual = update.chosenVariant.directorUpdate
      ? comparesDeltas(
          stage.state.value,
          actualDelta,
          update.chosenVariant.directorUpdate.code,
        )
      : actualDelta.length === 0;
    console.log("Deltas equal?", deltasEqual);

    if (!deltasEqual) {
      console.log("Saving actual delta as a new director update", actualDelta);

      promises.push(
        d.db
          .insert(d.directorUpdates)
          .values({
            writerUpdateId: update.chosenVariant.id,
            code: actualDelta,
          })
          .returning()
          .then((directorUpdates) => {
            update.chosenVariant.directorUpdate = directorUpdates[0];
          }),
      );
    }
  }

  await Promise.all(promises);

  previousStageState.value = clone(stage.state.value);
  console.debug("Saved stage state", previousStageState.value);
}

async function fadeCanvas(callback: () => Promise<void>): Promise<void> {
  try {
    _canvasFade.value = true;
    await callback();
  } finally {
    _canvasFade.value = false;
  }
}

/**
 * Explicitly regenerate an assistant update.
 */
async function regenerateAssistantUpdate(updateIndex: number) {
  if (busy.value) {
    throw new Error("Cannot regenerate while busy");
  }

  if (updateIndex !== 0) {
    throw new Error("Only the latest assistant update can be regenerated");
  }

  const regeneratedUpdate = updates.value[updateIndex];
  if (!(regeneratedUpdate instanceof AssistantUpdate)) {
    throw new Error(
      "`regenerateAssistantUpdate()` requires an assistant update",
    );
  }

  busy.value = true;
  regeneratedUpdate.newVariantInProgress.value = true;
  try {
    // OPTIMIZE: Infer while waiting for the fade.
    await fadeCanvas(async () => {
      stage.setState(previousStageState.value ?? null);
    });

    uncommittedAssistantText.value = "";

    const prompt =
      "\n" +
      (uncommittedWriterPrompt.value
        ? uncommittedWriterPrompt.value + "\n"
        : "") +
      writerResponsePrefix;
    console.log("Prompt", prompt);

    const writerResponse = await deferredWriter.promise.then((writer) =>
      writer.infer(prompt, 128, {
        stopSequences: ["\n"],
        grammar: writerGrammar,
        ...modelSettings.value,
      }),
    );

    const { writerUpdate } = await saveUpdatesToDb({
      writerUpdate: {
        parentUpdateId: regeneratedUpdate.parentId,
        text: writerResponse,
      },
    });

    uncommittedAssistantText.value = writerResponse;
    uncommittedWriterKvCacheKey.value = writerUpdate.id;

    regeneratedUpdate.variants.push({
      id: writerUpdate.id,
      text: writerUpdate.text,
      createdAt: writerUpdate.createdAt,
      directorUpdate: null,
    });

    regeneratedUpdate.chosenVariantIndex.value =
      regeneratedUpdate.variants.length - 1;
  } finally {
    regeneratedUpdate.newVariantInProgress.value = false;
    busy.value = false;
  }
}

/**
 * Send player message to the chat.
 * The message may be edited, so is not committed to GPT yet.
 */
async function sendPlayerMessage() {
  if (state.value.currentEpisode) {
    throw new Error("Player input not allowed during episode");
  }

  if (
    !(
      latestUpdate.value instanceof AssistantUpdate ||
      latestUpdate.value instanceof EpisodeUpdate
    )
  ) {
    throw new Error("Player input not allowed after player input");
  }

  let userMessage = playerInput.value;
  if (!userMessage) {
    throw new Error("Empty player input");
  }

  playerInput.value = "";
  let wouldRestorePlayerInput = true;

  busy.value = true;
  try {
    await commitUncommitted();

    // If the latest update is an episode update, use its ID as the parent ID.
    // Otherwise, use the latest assistant update's chosen variant ID.
    const parentUpdateId =
      latestUpdate.value instanceof AssistantUpdate
        ? latestUpdate.value.chosenVariant.id
        : latestUpdate.value.id;

    // Save the player update.
    let saved = await saveUpdatesToDb({
      writerUpdate: {
        parentUpdateId,
        text: userMessage,
        createdByPlayer: true,
      },
    });

    const userUpdateId = saved.writerUpdate.id;
    const userUpdate = markRaw(
      new UserUpdate(parentUpdateId, saved.writerUpdate),
    );
    updates.value.unshift(userUpdate);

    // TODO: Here, the empty updates array, it's cocky.
    const assistantUpdate = markRaw(new AssistantUpdate(userUpdateId, []));
    assistantUpdate.newVariantInProgress.value = true;
    updates.value.unshift(assistantUpdate);

    uncommittedPlayerInput.value = userMessage;

    const prompt =
      "\n" +
      (uncommittedWriterPrompt.value
        ? uncommittedWriterPrompt.value + "\n"
        : "") +
      writerResponsePrefix;
    console.log("Prompt", prompt);

    const writerResponse = await deferredWriter.promise.then((writer) =>
      writer.infer(prompt, 128, {
        stopSequences: ["\n"],
        grammar: writerGrammar,
        ...modelSettings.value,
      }),
    );

    // Save the assistant update.
    saved = await saveUpdatesToDb({
      writerUpdate: {
        parentUpdateId: userUpdateId,
        text: writerResponse,
      },
    });

    const assistantUpdateId = saved.writerUpdate.id;
    assistantUpdate.variants.push({
      id: assistantUpdateId,
      text: saved.writerUpdate.text,
      createdAt: saved.writerUpdate.createdAt,
      directorUpdate: null,
    });

    assistantUpdate.chosenVariantIndex.value = 0;
    assistantUpdate.newVariantInProgress.value = false;

    uncommittedAssistantText.value = writerResponse;
    uncommittedWriterKvCacheKey.value = assistantUpdateId;
  } catch (e) {
    if (wouldRestorePlayerInput) {
      playerInput.value = userMessage;
    }

    throw e;
  } finally {
    busy.value = false;
  }
}

/**
 * Move the story forward by either applying an episode update,
 * or by predicting the next update from the latent space.
 */
async function advance() {
  if (playerInput.value) {
    throw new Error("To advance, player input must be empty");
  }

  let parentUpdateId: string | null = null;
  if (latestUpdate.value instanceof AssistantUpdate) {
    parentUpdateId = latestUpdate.value.chosenVariant.id;
  } else if (latestUpdate.value instanceof UserUpdate) {
    parentUpdateId = latestUpdate.value.chosenVariant.id;
  } else if (latestUpdate.value instanceof EpisodeUpdate) {
    parentUpdateId = latestUpdate.value.id;
  }

  busy.value = true;
  try {
    await commitUncommitted();

    if (state.value.currentEpisode) {
      console.debug("Advancing episode", state.value.currentEpisode);

      const currentEpisode = state.value.currentEpisode;
      const episodeId = currentEpisode.id;
      const episodeChunkIndex = currentEpisode.nextChunkIndex;

      // Advance the episode.
      //

      const text =
        currentEpisode.chunks[currentEpisode.nextChunkIndex].writerUpdateText;

      const code =
        currentEpisode.chunks[currentEpisode.nextChunkIndex].stageCalls;

      if (code?.length) {
        const luaCode = stageCallsToLua(code);
        console.debug("Applying stage calls", luaCode);
        stage.apply(code);
        if (scene.busy) await scene.busy;
      }

      if (++currentEpisode.nextChunkIndex >= currentEpisode.chunks.length) {
        state.value.currentEpisode = null;
      }

      previousStageState.value = clone(stage.state.value);
      console.debug("Saved stage state", previousStageState.value);

      const incoming = await saveUpdatesToDb({
        writerUpdate: {
          parentUpdateId,
          text,
          episodeId,
          episodeChunkIndex,
        },
        directorUpdate: code ? { code } : undefined,
      });

      const episodeUpdate = markRaw(
        new EpisodeUpdate(
          incoming.writerUpdate.id,
          parentUpdateId,
          episodeId,
          episodeChunkIndex,
          text,
          incoming.directorUpdate ?? null,
        ),
      );

      updates.value.unshift(episodeUpdate);

      const newWriterPrompt = `\n${AI_PREFIX}${text}`;
      committedWriterPrompt.value += newWriterPrompt;
      deferredWriter.promise.then((writer) => writer.decode(newWriterPrompt));
    } else {
      // Predict the next update.
      // Do not commit it to GPT yet.
      //

      const assistantUpdate = markRaw(new AssistantUpdate(parentUpdateId, []));
      assistantUpdate.newVariantInProgress.value = true;
      updates.value.unshift(assistantUpdate);

      const prompt = "\n\n" + writerResponsePrefix;
      console.log("Prompt", prompt);

      const writerResponse = await deferredWriter.promise.then((writer) =>
        writer.infer(prompt, 128, {
          stopSequences: ["\n"],
          grammar: writerGrammar,
          ...modelSettings.value,
        }),
      );

      const { writerUpdate } = await saveUpdatesToDb({
        writerUpdate: {
          parentUpdateId,
          text: writerResponse,
        },
      });

      assistantUpdate.variants.push({
        id: writerUpdate.id,
        text: writerUpdate.text,
        createdAt: writerUpdate.createdAt,
        directorUpdate: null,
      });
      assistantUpdate.newVariantInProgress.value = false;

      uncommittedAssistantText.value = writerResponse;
      uncommittedWriterKvCacheKey.value = writerUpdate.id;
    }

    screenshot(true).then((shot) => {
      if (shot) {
        console.log("Saved screenshot", shot.path, prettyBytes(shot.size));
      }
    });
  } finally {
    busy.value = false;
  }
}

/**
 * Take a screenshot of the game, and save it at
 * `$APPLOCALDATA/screenshots/{simulationId}`.
 */
async function screenshot(
  rewrite: boolean,
): Promise<{ path: string; size: number } | null> {
  const path = await join(
    await appLocalDataDir(),
    "screenshots",
    `${simulationId}.jpg`,
  );

  if ((await exists(path)) && !rewrite) {
    return null;
  }

  const dataUri = gameInstance.screenshot("image/jpeg");
  const base64 = dataUri.split(",")[1];
  const buffer = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));

  await createDir("screenshots", {
    dir: BaseDirectory.AppLocalData,
    recursive: true,
  });
  await writeBinaryFile(path, buffer, { append: false });

  return { path, size: buffer.length };
}

/**
 * Save updates to the database.
 */
async function saveUpdatesToDb(updates: {
  writerUpdate: {
    parentUpdateId: string | undefined | null;
    text: string;
  } & (
    | {
        episodeId: string;
        episodeChunkIndex: number;
      }
    | {
        createdByPlayer: true;
      }
    | {}
  );
  directorUpdate?: {
    code: StageCall[];
  };
}) {
  return d.db.transaction(async (tx) => {
    const writerUpdate = (
      await tx
        .insert(d.writerUpdates)
        .values({
          simulationId,
          ...updates.writerUpdate,
        })
        .returning()
    )[0];

    let directorUpdate;
    if (updates.directorUpdate) {
      directorUpdate = (
        await tx
          .insert(d.directorUpdates)
          .values({
            writerUpdateId: writerUpdate.id,
            ...updates.directorUpdate,
          })
          .returning()
      )[0];
    }

    await tx
      .update(d.simulations)
      .set({
        headWriterUpdateId: writerUpdate.id,
        updatedAt: sql`CURRENT_TIMESTAMP`,
      })
      .where(eq(d.simulations.id, simulationId));

    return { writerUpdate, directorUpdate };
  });
}

/**
 * Prepare GPT backend for the simulation.
 */
async function prepareGpt() {
  const latestUpdate = updates.value.at(0);
  const previousUpdate = updates.value.at(1);

  /**
   * Committed updates, sorted from oldest to newest.
   */
  const committedUpdates: Update[] = updates.value.slice(2).reverse();

  // If the latest update is an episode update,
  // then it and the previous update are both committed.
  if (latestUpdate instanceof EpisodeUpdate) {
    if (previousUpdate) committedUpdates.push(previousUpdate);
    committedUpdates.push(latestUpdate);
  }

  // If the latest update is a user update,
  // then the previous update is committed, but not the latest.
  else if (latestUpdate instanceof UserUpdate) {
    if (previousUpdate) committedUpdates.push(previousUpdate);
    uncommittedPlayerInput.value = latestUpdate.chosenVariant.text;
  }

  // If the latest update is an assistant update,
  // then it is not committed... Should also check the previous update.
  else if (latestUpdate instanceof AssistantUpdate) {
    if (previousUpdate instanceof UserUpdate) {
      // Again, a user update is not committed.
      uncommittedPlayerInput.value = previousUpdate.chosenVariant.text;
    } else if (previousUpdate) {
      // Otherwise (assistant or episode update) it is committed.
      committedUpdates.push(previousUpdate);
    }

    uncommittedAssistantText.value = latestUpdate.chosenVariant.text;
  }

  const staticPrompt = buildStaticPrompt(scenario.value!);
  const dynamicPrompt = buildDynamicPrompt(committedUpdates);
  committedWriterPrompt.value += staticPrompt + dynamicPrompt;

  const createGpt = async (staticPrompt: string) => {
    const driver = (await settings.getGptDriver()) || "remote";

    switch (driver) {
      case "remote": {
        const baseUrl =
          (await settings.getGptRemoteBaseUrl()) ||
          import.meta.env.VITE_DEFAULT_REMOTE_INFERENCE_SERVER_BASE_URL;
        const model =
          (await settings.getGptRemoteModel()) ||
          import.meta.env.VITE_DEFAULT_REMOTE_GPT_INFERENCE_MODEL;

        return Gpt.create({ type: "remote", baseUrl, model }, staticPrompt);
      }

      case "local": {
        const modelPath = await settings.getGptLocalModelPath();
        if (!modelPath) throw new Error("Local model path not set");

        const contextSize = await settings.getGptLocalContextSize();
        if (!contextSize) throw new Error("Local context size not set");

        return Gpt.create(
          {
            type: "local",
            modelPath,
            contextSize,
            batchSize: contextSize,
          },
          staticPrompt,
        );
      }

      default:
        throw unreachable(driver);
    }
  };

  const { gpt } = await createGpt(staticPrompt);
  gpt.decode(dynamicPrompt);

  writer.value = markRaw(gpt);
  deferredWriter.resolve(writer.value);
}

async function fetchDirectorUpdates(writerUpdateIds: string[]) {
  return d.db
    .select({
      id: d.directorUpdates.id,
      writerUpdateId: d.directorUpdates.writerUpdateId,
      code: d.directorUpdates.code,
      createdAt: sql<string>`max(${d.directorUpdates.createdAt})`,
      llamaInferenceId: d.directorUpdates.llamaInferenceId,
    })
    .from(d.directorUpdates)
    .where(inArray(d.directorUpdates.writerUpdateId, writerUpdateIds))
    .groupBy(d.directorUpdates.writerUpdateId)
    .orderBy(asc(d.directorUpdates.createdAt))
    .all();
}

onMounted(async () => {
  const simulation = await d.db.query.simulations.findFirst({
    where: eq(d.simulations.id, simulationId),
  });

  if (!simulation) {
    throw new Error(`Simulation not found: ${simulationId}`);
  } else {
    console.log("Queried simulation", simulation);
  }

  scenario.value = await fetch(
    `/scenarios/${simulation.scenarioId}/manifest.json`,
  ).then((response) => response.json());
  if (!scenario.value) {
    throw new Error(`Scenario not found: ${simulation.scenarioId}`);
  } else {
    console.log("Fetched scenario", scenario.value);
  }

  // TODO: Fetch until `simulation.latestSnapshotId`.
  // NOTE: The ordering is from the oldest to the latest.
  const query = new SQLiteSyncDialect().sqlToQuery(
    sql.raw(`
      WITH
        writer_updates_tree AS (
          SELECT
            ${d.writerUpdates.id.name},
            ${d.writerUpdates.parentUpdateId.name},
            ${d.writerUpdates.createdByPlayer.name},
            ${d.writerUpdates.text.name},
            ${d.writerUpdates.episodeId.name},
            ${d.writerUpdates.episodeChunkIndex.name},
            ${d.writerUpdates.llamaInferenceId.name},
            ${d.writerUpdates.createdAt.name}
          FROM
            ${writerUpdatesTableName}
          WHERE
            ${d.writerUpdates.id.name} = ?
          UNION ALL
          SELECT
            parent.${d.writerUpdates.id.name},
            parent.${d.writerUpdates.parentUpdateId.name},
            parent.${d.writerUpdates.createdByPlayer.name},
            parent.${d.writerUpdates.text.name},
            parent.${d.writerUpdates.episodeId.name},
            parent.${d.writerUpdates.episodeChunkIndex.name},
            parent.${d.writerUpdates.llamaInferenceId.name},
            parent.${d.writerUpdates.createdAt.name}
          FROM
            ${writerUpdatesTableName} parent
            JOIN writer_updates_tree child ON child.${d.writerUpdates.parentUpdateId.name} = parent.${d.writerUpdates.id.name}
        )
      SELECT
        *
      FROM
        writer_updates_tree;
  `),
  );

  const result = await sqlite.query(query.sql, [simulation.headWriterUpdateId]);
  const writerUpdates = parseSelectResult(d.writerUpdates, result);

  // Assign the latest code updates to the writer updates.
  //

  const directorUpdates = await fetchDirectorUpdates(
    writerUpdates.map((u) => u.id),
  );

  updates.value = writerUpdates.map((writerUpdate) => {
    if (writerUpdate.createdByPlayer) {
      return markRaw(new UserUpdate(writerUpdate.parentUpdateId, writerUpdate));
    } else if (writerUpdate.episodeId) {
      return markRaw(
        new EpisodeUpdate(
          writerUpdate.id,
          writerUpdate.parentUpdateId,
          writerUpdate.episodeId,
          writerUpdate.episodeChunkIndex!,
          writerUpdate.text,
          directorUpdates.find(
            (directorUpdate) =>
              directorUpdate.writerUpdateId === writerUpdate.id,
          ) ?? null,
        ),
      );
    } else {
      return markRaw(
        new AssistantUpdate(writerUpdate.parentUpdateId, [
          {
            ...writerUpdate,
            directorUpdate:
              directorUpdates.find(
                (directorUpdate) =>
                  directorUpdate.writerUpdateId === writerUpdate.id,
              ) ?? null,
          },
        ]),
      );
    }
  });

  // If the newest update is an assistant update, also fetch its siblings.
  if (latestUpdate.value instanceof AssistantUpdate) {
    const preservedVariantId = latestUpdate.value.chosenVariant.id;

    const siblings = await d.db.query.writerUpdates.findMany({
      where: and(
        latestUpdate.value.parentId
          ? eq(d.writerUpdates.parentUpdateId, latestUpdate.value.parentId)
          : isNull(d.writerUpdates.parentUpdateId),
        eq(d.writerUpdates.simulationId, simulationId),
      ),
    });

    // Because it includes the latest update itself.
    assert(siblings.length > 0);

    // OPTIMIZE: Merge director update queries into one (see above).
    const directorUpdates = await fetchDirectorUpdates(
      siblings.map((u) => u.id),
    );

    latestUpdate.value.variants = siblings.map((writerUpdate) => ({
      ...writerUpdate,
      directorUpdate:
        directorUpdates.find(
          (directorUpdate) => directorUpdate.writerUpdateId === writerUpdate.id,
        ) || null,
    }));

    latestUpdate.value.chosenVariantIndex.value = assertFn(
      latestUpdate.value.variants.findIndex((v) => v.id === preservedVariantId),
      (index) => index >= 0,
    );
  }

  // TODO: Get initial stage value from the latest snapshot.
  stage = new Stage(scenario.value);
  await stage.initCodeEngine();

  if (updates.value.length) {
    // Apply existing director updates to the stage,
    // from oldest to newest (i.e. reverse).
    //

    // REFACTOR: It'd be more readable to do `i = updates.value.length`,
    // but the `i++` logic within the loop is not trivial.
    let i = updates.value.length;
    while (i > 0) {
      const update = updates.value[--i];
      let directorUpdate;

      if (update instanceof AssistantUpdate) {
        directorUpdate = update.chosenVariant.directorUpdate;
      } else if (update instanceof EpisodeUpdate) {
        directorUpdate = update.directorUpdate;
      }

      if (directorUpdate) {
        const luaCode = stageCallsToLua(directorUpdate.code);
        console.debug("Applying stage code", luaCode);
        stage.apply(directorUpdate.code);
      }

      // For the sake of regeneration, save the stage state at previous update.
      // But when there only one update, save the latest.
      if (updates.value.length == 1 || i === 1) {
        previousStageState.value = clone(stage.state.value);
        console.debug("Saved stage state", previousStageState.value);
      }
    }

    // If the latest update's (single) variant
    // has an episode ID, resume from there.
    if (latestUpdate.value instanceof EpisodeUpdate) {
      const episodeUpdate = latestUpdate.value;

      const episode = scenario.value.episodes.find(
        (e) => e.id === episodeUpdate.episodeId,
      );

      if (!episode) {
        throw new Error(`Episode not found: ${episodeUpdate.episodeId}`);
      }

      if (episodeUpdate.chunkIndex! < episode.chunks.length - 1) {
        state.value.currentEpisode = {
          ...episode,
          nextChunkIndex: episodeUpdate.chunkIndex! + 1,
        };
      }
    }
  }

  assetBaseUrl.value = new URL(
    `/scenarios/${simulation.scenarioId}/`,
    window.location.origin,
  );

  // REFACTOR: Scene creation shall be incapsulated.
  gameInstance = new Game();
  scene = new DefaultScene(
    scenario.value,
    assetBaseUrl.value.toString(),
    clone(stage.state.value),
    () => (_canvasFade.value = false),
  );
  await gameInstance.createScene(scene, "default");

  // Connect the stage to the scene.
  stage.connectScene(scene);

  // Register a console event listener.
  window.addEventListener("keypress", consoleEventListener);

  // ADHOC: Always create a screenshot upon running a simulation,
  // because there is currently no easy way to detect
  // if there have been any real updates.
  screenshot(false).then((shot) => {
    if (shot) {
      console.log("Saved screenshot", shot.path, prettyBytes(shot.size));
    }
  });

  await prepareGpt();
});

onUnmounted(() => {
  window.removeEventListener("keypress", consoleEventListener);
});

function chooseAssistantVariant(update: AssistantUpdate, variantIndex: number) {
  const code = update.variants[variantIndex].directorUpdate?.code;
  const actualDelta = stage.delta(previousStageState.value);

  function setUncommitted() {
    uncommittedAssistantText.value = update.variants[variantIndex].text;
    uncommittedWriterKvCacheKey.value = update.variants[variantIndex].id;
  }

  if (
    comparesDeltas(previousStageState.value ?? null, actualDelta, code ?? [])
  ) {
    fadeCanvas(async () => {
      stage.setState(previousStageState.value ?? null);
      const code = update.variants[variantIndex].directorUpdate?.code;
      if (code) stage.apply(code);
      setUncommitted();
    });
  } else {
    setUncommitted();
  }
}

/**
 * Inference a message in response to user input.
 */
// REFACTOR: Merge with `sendPlayerMessage`.
async function inferResponse(
  userUpdate: UserUpdate,
  assistantUpdate: AssistantUpdate | null,
) {
  console.trace({ userUpdate, assistantUpdate });
  let userMessageContent = userUpdate.chosenVariant.text;

  if (!assistantUpdate) {
    assistantUpdate = markRaw(
      new AssistantUpdate(userUpdate.chosenVariant.id, []),
    );

    updates.value.unshift(assistantUpdate);
  }

  assistantUpdate.newVariantInProgress.value = true;

  try {
    uncommittedPlayerInput.value = userMessageContent;

    const prompt =
      "\n" +
      (uncommittedWriterPrompt.value
        ? uncommittedWriterPrompt.value + "\n"
        : "") +
      writerResponsePrefix;
    console.log("Prompt", prompt);

    const writerResponse = await deferredWriter.promise.then((writer) =>
      writer.infer(prompt, 128, {
        stopSequences: ["\n"],
        grammar: writerGrammar,
        ...modelSettings.value,
      }),
    );

    // Save the assistant update.
    const saved = await saveUpdatesToDb({
      writerUpdate: {
        parentUpdateId: userUpdate.chosenVariant.id,
        text: writerResponse,
      },
    });

    const assistantUpdateId = saved.writerUpdate.id;
    assistantUpdate.variants.push({
      id: assistantUpdateId,
      text: saved.writerUpdate.text,
      createdAt: saved.writerUpdate.createdAt,
      directorUpdate: null,
    });
    assistantUpdate.chosenVariantIndex.value++;

    uncommittedAssistantText.value = writerResponse;
    uncommittedWriterKvCacheKey.value = assistantUpdateId;
  } finally {
    assistantUpdate.newVariantInProgress.value = false;
  }
}

async function onUserUpdateEdit(update: UserUpdate, newText: string) {
  console.debug("onUserUpdateEdit", newText);

  try {
    busy.value = true;

    const { writerUpdate: newWriterUpdate } = await saveUpdatesToDb({
      writerUpdate: {
        createdByPlayer: true,
        parentUpdateId: update.parentId,
        text: newText,
      },
    });

    update.chosenVariant = {
      id: newWriterUpdate.id,
      text: newWriterUpdate.text,
      createdAt: newWriterUpdate.createdAt,
    };

    await inferResponse(
      update,
      latestUpdate.value instanceof AssistantUpdate ? latestUpdate.value : null,
    );
  } finally {
    busy.value = false;
  }
}

async function onAssistantUpdateEdit(update: AssistantUpdate, newText: string) {
  console.debug("onUserUpdateEdit", newText);

  try {
    busy.value = true;

    await d.db
      .update(d.writerUpdates)
      .set({
        text: newText,
      })
      .where(eq(d.writerUpdates.id, update.chosenVariant.id));

    update.chosenVariant.text = newText;
    uncommittedAssistantText.value = newText;
  } finally {
    busy.value = false;
  }
}

function toMainMenu() {
  router.push(routeLocation({ name: "MainMenu" }));
}
</script>

<template lang="pug">
.flex.h-screen.w-screen
  .relative.flex.h-full.w-full.justify-center.overflow-hidden
    .relative.h-full.w-full
      TransitionRoot#canvas-fade.absolute.top-0.z-10.h-screen.w-screen.bg-black(
        :unmount="true"
        :show="_canvasFade"
        enter="transition-opacity duration-500 ease-in"
        enter-from="opacity-0"
        enter-to="opacity-100"
        leave="transition-opacity duration-500 ease-out"
        leave-from="opacity-100"
        leave-to="opacity-0"
      )

      #game-screen.h-full.w-full

    .absolute.top-0.z-20.flex.h-full.w-full.flex-col.items-center.gap-2
      .flex.w-full.justify-between.gap-2.px-2.pt-2
        button.rounded-lg.bg-black.bg-opacity-50.px-2.py-1.shadow.transition-transform.pressable(
          @click="showMenu = !showMenu"
        )
          MenuIcon.text-white(:size="20")

        button.rounded-lg.bg-black.bg-opacity-50.px-2.py-1.shadow.transition-transform.pressable(
          @click="showSandboxConsole = !showSandboxConsole"
        )
          ShapesIcon.text-white(v-if="!showSandboxConsole" :size="20")
          XIcon.text-white(v-else :size="20")

      .flex.h-full.w-full.max-w-xl.grow.flex-col.justify-end.gap-2.overflow-hidden.px-2
        ._updates-container.flex.w-full.flex-col-reverse.gap-2.overflow-y-scroll(
          ref="updatesRef"
          :style="{ '-webkit-mask-size': `100% calc(100% - ${updatesScrollOffsetY}px)`, 'max-height': `40%` }"
        )
          template(v-for="update, i of updates" :key="update.parentId")
            AssistantUpdateVue(
              v-if="AssistantUpdate.is(update)"
              :update="update"
              :can-regenerate="i === 0"
              :can-edit="i === 0"
              :show-variant-navigation="i === 0"
              @regenerate="regenerateAssistantUpdate(i)"
              @edit="(newText) => onAssistantUpdateEdit(update, newText)"
              @choose-variant="(variantIndex) => chooseAssistantVariant(update, variantIndex)"
            )
            UserUpdateVue(
              v-else-if="UserUpdate.is(update)"
              :update="update"
              :can-edit="i === 0 || i === 1"
              :show-variant-navigation="i === 0 || i === 1"
              @edit="(newText) => onUserUpdateEdit(update, newText)"
            )
            EpisodeUpdateVue(
              v-else-if="EpisodeUpdate.is(update)"
              :update="update"
            )

        .h-12.w-full
          .flex.h-full.gap-2.rounded
            input.h-full.w-full.rounded-lg.px-3.shadow-lg(
              v-model="playerInput"
              placeholder="Player input"
              :disabled="!userInputEnabled"
              class="disabled:opacity-50"
              @keydown.enter.exact="playerInput ? sendPlayerMessage() : advance()"
            )

            button.relative.grid.aspect-square.h-full.place-items-center.rounded-lg.bg-white.shadow-lg.transition.pressable(
              @click="playerInput ? sendPlayerMessage() : advance()"
              :disabled="busy"
            )
              //- REFACTOR: Make a component for such multi-state animations.
              TransitionRoot.absolute(
                :show="busy"
                enter="duration-100 ease-out"
                enter-from="scale-0 opacity-0"
                enter-to="scale-100 opacity-100"
                leave="duration-100 ease-in"
                leave-from="scale-100 opacity-100"
                leave-to="scale-0 opacity-0"
              )
                Loader2Icon.animate-spin(:size="20")
              TransitionRoot.absolute(
                :show="!busy && !!playerInput"
                enter="duration-100 ease-out"
                enter-from="scale-0 opacity-0"
                enter-to="scale-100 opacity-100"
                leave="duration-100 ease-in"
                leave-from="scale-100 opacity-100"
                leave-to="scale-0 opacity-0"
              )
                SendHorizontalIcon(:size="20")
              TransitionRoot.absolute(
                :show="!busy && !playerInput && !state.currentEpisode"
                enter="duration-100 ease-out"
                enter-from="scale-0 opacity-0"
                enter-to="scale-100 opacity-100"
                leave="duration-100 ease-in"
                leave-from="scale-100 opacity-100"
                leave-to="scale-0 opacity-0"
              )
                FastForwardIcon(:size="20")
              TransitionRoot.absolute(
                :show="!busy && !playerInput && !!state.currentEpisode"
                enter="duration-100 ease-out"
                enter-from="scale-0 opacity-0"
                enter-to="scale-100 opacity-100"
                leave="duration-100 ease-in"
                leave-from="scale-100 opacity-100"
                leave-to="scale-0 opacity-0"
              )
                SkipForwardIcon(:size="20")

      .flex.w-full.justify-between.bg-white.bg-opacity-50.p-2
        span {{ scenario?.name }}: {{ simulationId }}
        .flex.gap-2
          .flex.items-center.gap-1
            GptStatus(:gpt="writer" :icon-size="22")
              ScrollTextIcon(:size="18")

  TransitionRoot.h-full.shrink-0(
    class="w-1/3"
    :unmount="true"
    :show="showSandboxConsole"
    enter="transition duration-200 ease-in"
    enter-from="opacity-0 translate-x-full"
    enter-to="opacity-100 translate-x-0"
    leave="transition duration-200 ease-out"
    leave-from="opacity-100 translate-x-0"
    leave-to="opacity-0 translate-x-full"
  )
    SandboxConsole.h-full(
      v-if="scenario && assetBaseUrl"
      :asset-base-url="assetBaseUrl"
      :scenario="scenario"
      :stage="stage"
    )

  DeveloperConsole(
    :open="consoleModal"
    :writer="writer"
    :writer-prompt="committedWriterPrompt"
    :uncommitted-writer-prompt="uncommittedWriterPrompt"
    :episode="currentEpisodeConsoleObject"
    :stage-state-delta="stage?.delta(previousStageState) || []"
    @close="consoleModal = false"
  )

  Menu(:open="showMenu" @close="showMenu = false" @to-main-menu="toMainMenu")
</template>

<style lang="scss" scoped>
._updates-container {
  -webkit-mask-image: -webkit-gradient(
    linear,
    left top,
    left bottom,
    color-stop(0%, rgba(0, 0, 0, 0)),
    color-stop(50%, rgba(0, 0, 0, 1))
  );

  -webkit-mask-repeat: no-repeat;
  -webkit-mask-position-y: 100%;
}
</style>
